--- modules/core/src/persistence.cpp
+++ modules/core/src/persistence.cpp
@@ -1367,7 +1367,7 @@
             CV_PARSE_ERROR("Unrecognized Base64 header");
 
         std::vector<char> header(base64::HEADER_SIZE + 1, ' ');
-        base64::base64_decode(beg, header.data(), 0U, base64::ENCODED_HEADER_SIZE);
+        base64::base64_decode(beg, &header.front(), 0U, base64::ENCODED_HEADER_SIZE);
         if ( !base64::read_base64_header(header, dt) || dt.empty() )
             CV_PARSE_ERROR("Invalid `dt` in Base64 header");
 
@@ -1383,17 +1383,17 @@
         beg = end;
         icvYMLGetMultilineStringContent( fs, beg, indent, beg, end );
     }
-    if ( !base64::base64_valid(base64_buffer.data(), 0U, base64_buffer.size()) )
+    if ( !base64::base64_valid(&base64_buffer.front(), 0U, base64_buffer.size()) )
         CV_PARSE_ERROR( "Invalid Base64 data." );
 
     /* buffer for decoded data(exclude header) */
     std::vector<uchar> binary_buffer( base64::base64_decode_buffer_size(base64_buffer.size()) );
     int total_byte_size = static_cast<int>(
-        base64::base64_decode_buffer_size( base64_buffer.size(), base64_buffer.data(), false )
+        base64::base64_decode_buffer_size( base64_buffer.size(), &base64_buffer.front(), false )
         );
     {
-        base64::Base64ContextParser parser(binary_buffer.data(), binary_buffer.size() );
-        const uchar * buffer_beg = reinterpret_cast<const uchar *>( base64_buffer.data() );
+        base64::Base64ContextParser parser(&binary_buffer.front(), binary_buffer.size() );
+        const uchar * buffer_beg = reinterpret_cast<const uchar *>( &base64_buffer.front() );
         const uchar * buffer_end = buffer_beg + base64_buffer.size();
         parser.read( buffer_beg, buffer_end );
         parser.flush();
@@ -1409,7 +1409,7 @@
     int struct_flags = CV_NODE_FLOW | CV_NODE_SEQ;
     /* after icvFSCreateCollection, node->tag == struct_flags */
     icvFSCreateCollection(fs, struct_flags, node);
-    base64::make_seq(binary_buffer.data(), elem_cnt, dt.c_str(), *node->data.seq);
+    base64::make_seq(&binary_buffer.front(), elem_cnt, dt.c_str(), *node->data.seq);
 
     if (fs->dummy_eof) {
         /* end of file */
@@ -2326,7 +2326,7 @@
             CV_PARSE_ERROR("Unrecognized Base64 header");
 
         std::vector<char> header(base64::HEADER_SIZE + 1, ' ');
-        base64::base64_decode(beg, header.data(), 0U, base64::ENCODED_HEADER_SIZE);
+        base64::base64_decode(beg, &header.front(), 0U, base64::ENCODED_HEADER_SIZE);
         if ( !base64::read_base64_header(header, dt) || dt.empty() )
             CV_PARSE_ERROR("Invalid `dt` in Base64 header");
 
@@ -2342,17 +2342,17 @@
         beg = end;
         icvXMLGetMultilineStringContent( fs, beg, beg, end );
     }
-    if ( !base64::base64_valid(base64_buffer.data(), 0U, base64_buffer.size()) )
+    if ( !base64::base64_valid(&base64_buffer.front(), 0U, base64_buffer.size()) )
         CV_PARSE_ERROR( "Invalid Base64 data." );
 
     /* alloc buffer for all decoded data(include header) */
     std::vector<uchar> binary_buffer( base64::base64_decode_buffer_size(base64_buffer.size()) );
     int total_byte_size = static_cast<int>(
-        base64::base64_decode_buffer_size( base64_buffer.size(), base64_buffer.data(), false )
+        base64::base64_decode_buffer_size( base64_buffer.size(), &base64_buffer.front(), false )
         );
     {
-        base64::Base64ContextParser parser(binary_buffer.data(), binary_buffer.size() );
-        const uchar * buffer_beg = reinterpret_cast<const uchar *>( base64_buffer.data() );
+        base64::Base64ContextParser parser(&binary_buffer.front(), binary_buffer.size() );
+        const uchar * buffer_beg = reinterpret_cast<const uchar *>( &base64_buffer.front() );
         const uchar * buffer_end = buffer_beg + base64_buffer.size();
         parser.read( buffer_beg, buffer_end );
         parser.flush();
@@ -2368,7 +2368,7 @@
     int struct_flags = CV_NODE_SEQ;
     /* after icvFSCreateCollection, node->tag == struct_flags */
     icvFSCreateCollection(fs, struct_flags, node);
-    base64::make_seq(binary_buffer.data(), elem_cnt, dt.c_str(), *node->data.seq);
+    base64::make_seq(&binary_buffer.front(), elem_cnt, dt.c_str(), *node->data.seq);
 
     if (fs->dummy_eof) {
         /* end of file */
@@ -3457,14 +3457,14 @@
 
             if ( base64_buffer.size() >= base64::ENCODED_HEADER_SIZE )
             {
-                const char * base64_beg = base64_buffer.data();
+                const char * base64_beg = &base64_buffer.front();
                 const char * base64_end = base64_beg + base64_buffer.size();
 
                 /* get dt from header */
                 std::string dt;
                 {
                     std::vector<char> header(base64::HEADER_SIZE + 1, ' ');
-                    base64::base64_decode(base64_beg, header.data(), 0U, base64::ENCODED_HEADER_SIZE);
+                    base64::base64_decode(base64_beg, &header.front(), 0U, base64::ENCODED_HEADER_SIZE);
                     if ( !base64::read_base64_header(header, dt) || dt.empty() )
                         CV_PARSE_ERROR("Invalid `dt` in Base64 header");
                 }
@@ -3483,7 +3483,7 @@
                         base64::base64_decode_buffer_size( base64_end - base64_beg, base64_beg, false )
                         );
                     {
-                        base64::Base64ContextParser parser(binary_buffer.data(), binary_buffer.size() );
+                        base64::Base64ContextParser parser(&binary_buffer.front(), binary_buffer.size() );
                         const uchar * binary_beg = reinterpret_cast<const uchar *>( base64_beg );
                         const uchar * binary_end = binary_beg + (base64_end - base64_beg);
                         parser.read( binary_beg, binary_end );
@@ -3498,7 +3498,7 @@
 
                     /* after icvFSCreateCollection, node->tag == struct_flags */
                     icvFSCreateCollection(fs, CV_NODE_FLOW | CV_NODE_SEQ, node);
-                    base64::make_seq(binary_buffer.data(), elem_cnt, dt.c_str(), *node->data.seq);
+                    base64::make_seq(&binary_buffer.front(), elem_cnt, dt.c_str(), *node->data.seq);
                 }
                 else
                 {
@@ -7658,7 +7658,7 @@
 
 bool base64::read_base64_header(std::vector<char> const & header, std::string & dt)
 {
-    std::istringstream iss(header.data());
+    std::istringstream iss(&header.front());
     return static_cast<bool>(iss >> dt);
 }
 
@@ -7675,7 +7675,7 @@
     , src_end(0)
     , binary_buffer(base64_encode_buffer_size(BUFFER_LEN))
 {
-    src_beg = binary_buffer.data();
+    src_beg = &binary_buffer.front();
     src_cur = src_beg;
     src_end = src_beg + BUFFER_LEN;
 }
@@ -7719,7 +7719,7 @@
     if ( src_cur == src_beg )
         return true;
 
-    uchar * buffer = binary_buffer.data();
+    uchar * buffer = &binary_buffer.front();
     size_t len = base64_decode(src_beg, buffer, 0U, src_cur - src_beg);
     src_cur = src_beg;
 
@@ -7758,7 +7758,7 @@
         , src_cur(0)
         , src_end(0)
     {
-        src_beg = binary_buffer.data();
+        src_beg = &binary_buffer.front();
         src_end = src_beg + BUFFER_LEN;
         src_cur = src_beg;
 
@@ -7829,7 +7829,7 @@
         static const size_t BUFFER_MAX_LEN = 1024U;
 
         std::vector<uchar> buffer(BUFFER_MAX_LEN);
-        uchar * beg = buffer.data();
+        uchar * beg = &buffer.front();
         uchar * end = beg;
 
         while (convertor) {
@@ -7844,7 +7844,7 @@
     bool flush()
     {
         /* controll line width, so on. */
-        size_t len = base64_encode(src_beg, base64_buffer.data(), 0U, src_cur - src_beg);
+        size_t len = base64_encode(src_beg, &base64_buffer.front(), 0U, src_cur - src_beg);
         if (len == 0U)
             return false;
 
@@ -7852,7 +7852,7 @@
         {
             if ( file_storage->fmt == CV_STORAGE_FORMAT_JSON )
             {
-                ::icvPuts(file_storage, (const char*)base64_buffer.data());
+                ::icvPuts(file_storage, (const char*)&base64_buffer.front());
             }
             else
             {
@@ -7863,7 +7863,7 @@
                 space[ident] = '\0';
 
                 ::icvPuts(file_storage, space);
-                ::icvPuts(file_storage, (const char*)base64_buffer.data());
+                ::icvPuts(file_storage, (const char*)&base64_buffer.front());
                 ::icvPuts(file_storage, newline);
                 ::icvFSFlush(file_storage);
             }
@@ -8230,7 +8230,7 @@
 
         /* output header */
         std::string buffer = make_base64_header(dt);
-        const uchar * beg = reinterpret_cast<const uchar *>(buffer.data());
+        const uchar * beg = reinterpret_cast<const uchar *>(&buffer.front());
         const uchar * end = beg + buffer.size();
 
         emitter->write(beg, end);

